<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ import namespace="System.Globalization" #>
<#@ assembly name="$(TargetPath)" #>
<#@ import namespace="Gu.Units.Generator" #>
<#@ parameter name="UnitData" type="Gu.Units.Generator.IUnit" #>
<#@ output extension=".txt" #>
<#
// Template used by UnitGenerator.tt
IUnit unit;
if(UnitData != null)
{
    unit = UnitData;
}
else
{
    unit = new SiUnit("Metres", "m")
                    {
                        QuantityName =  "Length"
                    };
    unit.Conversions.Add(new Conversion("Centimetres", "cm"));
    unit.Conversions.Add(new Conversion("Millimetres", "mm"));
}
#>
namespace <#= Settings.Namespace #>
{
    using System;
    using System.ComponentModel;
    using System.Diagnostics;

    /// <summary>
    /// A type for the unit <see cref="<#= Settings.Namespace #>.<#= unit.UnitName #>"/>.
	/// Contains conversion logic.
    /// </summary>
    [Serializable, TypeConverter(typeof(<#= unit.UnitName #>TypeConverter)), DebuggerDisplay("1{symbol} == {ToSiUnit(1)}{<#= unit.ClassName #>.symbol}")]
    public struct <#= unit.UnitName #> : IUnit, IUnit<<#= unit.QuantityName #>>, IEquatable<<#= unit.UnitName #>>
    {
        /// <summary>
        /// The <#= unit.ClassName #> unit
        /// Contains conversion logic to from and formatting.
        /// </summary>
<#
	if (unit.AnyOffsetConversion)
	{
	    #>
        public static readonly <#= unit.UnitName #> <#= unit.ClassName #> = new <#= unit.UnitName #>(1.0, 0, "<#= unit.Symbol #>");
<#
	}
	else
	{
	    #>
        public static readonly <#= unit.UnitName #> <#= unit.ClassName #> = new <#= unit.UnitName #>(1.0, "<#= unit.Symbol #>");
<#
	}
        #>
<#
		    if(unit.IsSymbolNameValid)
            {
		    #>

        /// <summary>
        /// The <#= unit.ClassName #> unit
        /// Contains conversion logic to from and formatting.
        /// </summary>
		public static readonly <#= unit.UnitName #> <#= unit.Symbol #> = <#= unit.ClassName #>;
<#
            }
            #><#
		foreach(var su in unit.Conversions)
        {
		#>

        /// <summary>
        /// The <#= su.ClassName #> unit
        /// Contains conversion logic to from and formatting.
        /// </summary>
<#
	if (unit.AnyOffsetConversion)
	{
	    #>
		public static readonly <#= unit.UnitName #> <#= su.ClassName #> = new <#= unit.UnitName #>(<#= su.Formula.ConversionFactor #>, <#= su.Formula.Offset #>, "<#= su.Symbol #>");
<#
	}
	else
	{
	    #>
		public static readonly <#= unit.UnitName #> <#= su.ClassName #> = new <#= unit.UnitName #>(<#= su.Formula.ConversionFactor.ToString("R", CultureInfo.InvariantCulture) #>, "<#= su.Symbol #>");
<#
	}
        #><#
		    if(su.IsSymbolNameValid)
            {
		    #>

        /// <summary>
        /// The <#= su.ClassName #> unit
        /// Contains conversion logic to from and formatting.
        /// </summary>
		public static readonly <#= unit.UnitName #> <#= su.Symbol #> = <#= su.ClassName #>;
<#
            }
            #><#
        }
        #>

		private readonly double conversionFactor;
<#
	if(unit.AnyOffsetConversion)
    {
	#>
        private readonly double offset;
<#
    }
        #>
        private readonly string symbol;

<#
	if (unit.AnyOffsetConversion)
	{
	    #>
        public <#= unit.UnitName #>(double conversionFactor, double offset, string symbol)
<#
	}
	else
	{
	    #>
        public <#= unit.UnitName #>(double conversionFactor, string symbol)
<#
	}
        #>
        {
            this.conversionFactor = conversionFactor;
<#
	if(unit.AnyOffsetConversion)
    {
	#>
        this.offset = offset;
<#
    }
        #>
            this.symbol = symbol;
        }

		/// <summary>
        /// The symbol for the <see cref="<#= Settings.Namespace #>.<#= unit.UnitName #>"/>.
        /// </summary>
        public string Symbol
        {
            get
            {
                return this.symbol;
            }
        }

		/// <summary>
        /// The default unit for <see cref="<#= Settings.Namespace #>.<#= unit.UnitName #>"/>
        /// </summary>
        public <#= unit.UnitName #> SiUnit => <#= unit.UnitName #>.<#= unit.ClassName #>;

		/// <summary>
        /// The default <see cref="<#= Settings.Namespace #>.IUnit"/> for <see cref="<#= Settings.Namespace #>.<#= unit.UnitName #>"/>
        /// </summary>
        IUnit IUnit.SiUnit => <#= unit.UnitName #>.<#= unit.ClassName #>;

        public static <#= unit.QuantityName #> operator *(double left, <#= unit.UnitName #> right)
        {
            return <#= unit.QuantityName #>.From(left, right);
        }

	    public static bool operator ==(<#= unit.UnitName #> left, <#= unit.UnitName #> right)
        {
            return left.Equals(right);
        }

        public static bool operator !=(<#= unit.UnitName #> left, <#= unit.UnitName #> right)
        {
            return !left.Equals(right);
        }

        public static <#= unit.UnitName #> Parse(string text)
        {
            return UnitParser<<#= unit.UnitName #>>.Parse(text);
        }

        public static bool TryParse(string text, out <#= unit.UnitName #> value)
        {
            return UnitParser<<#= unit.UnitName #>>.TryParse(text, out value);
        }

        /// <summary>
        /// Converts <paramref name="value"/> to <#= unit.ClassName #>.
        /// </summary>
        /// <param name="value"></param>
        /// <returns>The converted value</returns>
        public double <#= Gu.Units.Generator.Names.ToSiUnit #>(double value)
        {
<#
	if (unit.AnyOffsetConversion)
	{
	    #>
			return (value - this.offset) /  this.conversionFactor;
<#
	}
	else
	{
	    #>
            return this.conversionFactor * value;
<#
	}
        #>
        }

        /// <summary>
        /// Converts a value from <#= unit.ClassName #>.
        /// </summary>
        /// <param name="value">The value in <#= unit.ClassName #></param>
        /// <returns>The converted value</returns>
        public double <#= Gu.Units.Generator.Names.FromSiUnit #>(double value)
        {
<#
	if (unit.AnyOffsetConversion)
	{
	    #>
			return this.conversionFactor * value + this.offset;
<#
	}
	else
	{
	    #>
            return value / this.conversionFactor;
<#
	}
        #>
        }

        /// <summary>
        /// Creates a quantity with this unit
        /// </summary>
        /// <param name="value"></param>
        /// <returns>new <#= unit.QuantityName #>(value, this)</returns>
        public <#= unit.QuantityName #> CreateQuantity(double value)
        {
            return new <#= unit.QuantityName #>(value, this);
        }

		/// <summary>
        /// Gets the scalar value of <paramref name="quantity"/> in <#= unit.ClassName #>
        /// </summary>
        /// <param name="quantity"></param>
        /// <returns></returns>
        public double GetScalarValue(<#= unit.QuantityName #> quantity)
        {
            return FromSiUnit(quantity.<#= unit.ParameterName #>);
        }

        public override string ToString()
        {
            return this.symbol;
        }

		public bool Equals(<#= unit.UnitName #> other)
        {
            return this.symbol == other.symbol;
        }

        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj))
            {
                return false;
            }

            return obj is <#= unit.UnitName #> && Equals((<#= unit.UnitName #>) obj);
        }

        public override int GetHashCode()
        {
            if (this.symbol == null)
            {
                return 0; // Needed due to default ctor
            }

            return this.symbol.GetHashCode();
        }
    }
}